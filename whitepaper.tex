\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{parskip}

\geometry{
    a4paper,
    total={170mm,257mm},
    left=20mm,
    top=20mm,
}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={VoidBox Whitepaper},
    pdfpagemode=FullScreen,
}

\title{\textbf{\Huge VoidBox} \\ \Large A Pragmatic Approach to Universal Linux Applications}
\author{The VoidBox Team}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
	The Linux desktop ecosystem has long struggled with application distribution fragmentation. While solutions like Snap, Flatpak, and AppImage have attempted to solve this, they often introduce new compromises regarding performance, disk usage, usability, or developer workflow. VoidBox proposes a new paradigm: a universal application platform that prioritizes portability and "out-of-the-box" usability over restrictive sandboxing. By leveraging unprivileged Linux user namespaces without requiring root daemons or complex runtimes, VoidBox offers a lightweight, native-feeling experience that works across virtually any Linux distribution.
\end{abstract}

\tableofcontents

\section{Introduction}
The promise of "write once, run anywhere" has eluded the Linux desktop for decades. Developers are forced to choose between packaging for specific distributions (Debian/Ubuntu, Fedora, Arch) or adopting universal formats that often alienate users through performance overhead or poor system integration.

The current leading solutions prioritize isolation and security, often at the cost of user experience. They treat the user as a threat to be contained, rather than an owner of their system. This results in applications that cannot access user files, do not respect system themes, and fail to interact with host development tools.

VoidBox was created to fill the gap for users who want portable applications that simply work, respecting the user's agency and the system's resources.

\section{The Landscape of Linux Packaging}

\subsection{System Package Managers}
Traditional package managers (APT, DNF, Pacman) provide excellent integration and shared libraries but suffer from fragmentation. A developer cannot easily distribute a single binary that works on Ubuntu 20.04, Fedora 40, and Arch Linux simultaneously due to glibc version mismatches and dependency hell.

\subsection{The "Universal" Contenders}

\subsubsection{Snap (Canonical)}
Snap relies on a centralized store and a heavy background daemon (`snapd`). While it solves the distribution problem, it introduces significant downsides:
\begin{itemize}
	\item \textbf{Slow Startup}: Uses compressed file systems that are slow to mount and read.
	\item \textbf{Forced Updates}: Users cannot opt-out of updates, breaking workflows.
	\item \textbf{Proprietary Backend}: The server side is closed source, controlled solely by Canonical.
\end{itemize}

\subsubsection{Flatpak (Red Hat / Community)}
Flatpak is the current community standard but suffers from "security theater" and complexity:
\begin{itemize}
	\item \textbf{Disk Bloat}: Requires massive runtime libraries (GNOME, KDE runtimes often exceed 1GB).
	\item \textbf{Sandbox Friction}: Apps often cannot access the user's home directory or system tools without complex permission overrides (Portals).
	\item \textbf{Developer Isolation}: IDEs running in Flatpak cannot see the host's compilers or SDKs (pip, npm, cargo), breaking development workflows.
\end{itemize}

\subsubsection{AppImage}
AppImage offers simplicity ("one file = one app") but lacks management features:
\begin{itemize}
	\item \textbf{No Updates}: No built-in mechanism to update the binary.
	\item \textbf{No Integration}: Does not automatically create menu entries or file associations.
	\item \textbf{Library Issues}: Often breaks when the host's glibc is newer or older than expected.
\end{itemize}

\section{The VoidBox Philosophy}

VoidBox is built on four core principles designed to address the shortcomings of existing solutions.

\subsection{1. Portability First}
VoidBox applications carry their own dependencies (or use shared base layers) and run in isolated namespaces. This ensures they work identically on any Linux distribution with a kernel version of 3.8 or higher.

\subsection{2. Usability Over Restrictive Sandboxing}
Unlike Flatpak or Snap, VoidBox follows an "Open by Default" policy. We assume the user wants to use the application. Therefore, by default:
\begin{itemize}
	\item Applications can read/write to the user's Home directory.
	\item Hardware acceleration (GPU) is enabled.
	\item Audio and webcams work immediately.
\end{itemize}
Security-conscious users can opt-in to restrictions, but the default experience is friction-less.

\subsection{3. No Daemon, No Root}
VoidBox runs entirely in userspace. There is no background service consuming RAM and no root access required to install or run applications. It utilizes unprivileged user namespaces to create isolated environments safely.

\subsection{4. Native Performance}
By avoiding heavy compression algorithms for execution and eliminating intermediate daemon layers, VoidBox applications start as fast as native system packages.

\section{Technical Architecture}

\subsection{Namespace Isolation}
VoidBox utilizes Linux kernel namespaces to create a containerized environment without the overhead of Docker:
\begin{itemize}
	\item \textbf{User Namespace}: Maps the user's UID to root inside the container, allowing package installation and manipulation without actual system root privileges.
	\item \textbf{Mount Namespace}: Provides a clean file system view, allowing the app to see its own libraries in `/usr/lib` without conflicting with the host.
\end{itemize}

\subsection{Seamless Integration}
To ensure apps feel native, VoidBox automatically performs bind mounts from the host to the container:
\begin{itemize}
	\item \textbf{X11/Wayland}: Sockets are passed through for graphical display.
	\item \textbf{Audio}: PulseAudio and PipeWire sockets are mounted.
	\item \textbf{Themes \& Fonts}: System fonts and themes are mounted read-only, ensuring apps match the user's desktop aesthetic.
\end{itemize}

\section{Future Roadmap}
\begin{itemize}
	\item \textbf{Shared Base Layers}: Implementation of OverlayFS to allow multiple apps to share a common base image (e.g., Ubuntu 24.04), reducing disk usage drastically.
	\item \textbf{Decentralized Registry}: A community-driven, federated registry system for discovering applications without corporate gatekeepers.
	\item \textbf{Delta Updates}: Bandwidth-efficient updates that only download changed binary parts.
\end{itemize}

\section{Conclusion}
VoidBox represents a return to simplicity. It acknowledges that for most desktop users, the priority is having applications that work, look good, and don't slow down the system. By leveraging modern kernel features in a pragmatic way, VoidBox delivers the reliability of containers with the usability of native applications.

\end{document}
